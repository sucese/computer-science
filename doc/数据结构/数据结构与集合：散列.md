# æ•°æ®ç»“æ„ä¸é›†åˆï¼šæ•£åˆ—

**å…³äºä½œè€…**

>éƒ­å­æ˜Ÿï¼Œç¨‹åºå‘˜ï¼Œå‰ä»–æ‰‹ï¼Œä¸»è¦ä»äº‹Androidå¹³å°åŸºç¡€æ¶æ„æ–¹é¢çš„å·¥ä½œï¼Œæ¬¢è¿äº¤æµæŠ€æœ¯æ–¹é¢çš„é—®é¢˜ï¼Œå¯ä»¥å»æˆ‘çš„[Github](https://github.com/guoxiaoxing)æissueæˆ–è€…å‘é‚®ä»¶è‡³guoxiaoxingse@163.comä¸æˆ‘äº¤æµã€‚

**æ–‡ç« ç›®å½•**`       

- ä¸€ HashMapçš„å®ç°åŸç†
- äºŒ HashSetçš„å®ç°åŸç†
    
æ›´å¤šæ–‡ç« è¯·å‚è§ï¼š[Data Structure And Algorithm](https://github.com/guoxiaoxing/computer-science/blob/master/README.md)

> æ•£åˆ—æ˜¯ä¸€ç§å¯¹ä¿¡æ¯çš„å¤„ç†æ–¹æ³•ï¼Œé€šè¿‡ç‰¹å®šçš„ç®—æ³•å°†è¦æ£€ç´¢çš„é¡¹ä¸ç”¨æ¥æ£€ç´¢çš„ç´¢å¼•ï¼ˆæ•£åˆ—å€¼ï¼‰å…³è”èµ·æ¥ï¼Œç”Ÿæˆä¸€ç§ä¾¿äºæœç´¢çš„æ•°æ®ç»“æ„æ•£åˆ—è¡¨ã€‚

æ•£åˆ—çš„åº”ç”¨

- åŠ å¯†æ•£åˆ—ï¼šåœ¨ä¿¡æ¯å®‰å…¨ä½¿ç”¨ï¼Œä¾‹å¦‚SHA-1åŠ å¯†ç®—æ³•ã€‚
- æ•£åˆ—è¡¨ï¼šä¸€ç§ä½¿ç”¨æ•£åˆ—å–Šå‡ºå°†é”®åä¸é”®å€¼å…³è”èµ·æ¥çš„æ•°æ®ç»“æ„ã€‚
- å…³è”æ•°ç»„ï¼šä¸€ç§ä½¿ç”¨æ•£åˆ—è¡¨å®ç°çš„æ•°æ®ç»“æ„ã€‚
- å‡ ä½•æ•£åˆ—ï¼šæŸ¥è¯¢ç›¸åŒæˆ–ç›¸ä¼¼å‡ ä½•å½¢çŠ¶çš„ä¸€ç§æœ‰æ•ˆæ–¹æ³•ã€‚

æˆ‘ä»¬ä¸»è¦æ¥è®¨è®ºæ•£åˆ—è¡¨çš„åº”ç”¨ï¼Œæ•£åˆ—å€¼ä¹Ÿå³å“ˆå¸Œå€¼ï¼Œæåˆ°å“ˆå¸Œå€¼ï¼Œæˆ‘ä»¬ä¸ç¦ä¼šè”æƒ³åˆ°Javaé‡Œåˆ°hashCode()æ–¹æ³•ä¸equals()æ–¹æ³•ã€‚

> hashCode()æ–¹æ³•è¿”å›è¯¥å¯¹è±¡çš„å“ˆå¸Œç å€¼ï¼Œåœ¨ä¸€æ¬¡Javaåº”ç”¨è¿è¡ŒæœŸé—´ï¼Œå¦‚æœè¯¥å¯¹è±¡ä¸Šequals()æ–¹æ³•é‡Œæ¯”è¾ƒçš„ä¿¡æ¯æ²¡æœ‰ä¿®æ”¹ï¼Œåˆ™å¯¹è¯¥å¯¹è±¡å¤šæ¬¡è°ƒç”¨hashCode()æ–¹æ³•æ—¶è¿”å›
ç›¸åŒçš„æ•´æ•°ã€‚

ä»è¿™ä¸ªå®šä¹‰æˆ‘ä»¬å¯ä»¥äº†è§£åˆ°ä»¥ä¸‹å‡ ç‚¹ï¼š

- å½“equals()æ–¹æ³•è¢«é‡å†™æ—¶ï¼Œé€šå¸¸æœ‰å¿…è¦é‡å†™hashCode()æ–¹æ³•ï¼Œä»¥ç»´æŠ¤hashCode()æ–¹æ³•çš„å¸¸è§„åå®šï¼Œè¯¥åå®šå£°æ˜ç›¸ç­‰å¯¹è±¡å¿…é¡»å…·æœ‰ç›¸ç­‰çš„å“ˆå¸Œç ã€‚
- hashCodeçš„å­˜åœ¨ä¸»è¦ç”¨æ¥æå‡æŸ¥æ‰¾çš„å¿«æ·æ€§ï¼ŒHashMapã€Hashtableç­‰ç”¨hashCodeæ¥ç¡®å®šæ•£åˆ—è¡¨ä¸­å¯¹è±¡çš„å­˜å‚¨åœ°å€ã€‚
- ä¸¤ä¸ªå¯¹è±¡ç›¸åŒï¼Œåˆ™ä¸¤ä¸ªå¯¹è±¡çš„hashCodeç›¸åŒï¼Œåè¿‡æ¥å´ä¸ä¸€å®šï¼ŒhashCodeç›¸åŒåªèƒ½è¯´æ˜è¿™ä¸¤ä¸ªå¯¹è±¡æ”¾åœ¨æ•£åˆ—è¡¨é‡Œçš„åŒä¸€ä¸ª"ç¯®å­"é‡Œã€‚

æˆ‘ä»¬å†é‡å†™hashCode()æ–¹æ³•æ—¶ï¼Œé€šå¸¸ç”¨ä»¥ä¸‹æ–¹å¼æ¥è®¡ç®—hashCodeï¼š

1 å°†ä¸€ä¸ªé0çš„å¸¸æ•°å€¼ä¿å­˜åˆ°ä¸€ä¸ªåä¸ºresultçš„intå‹å˜é‡ä¸­ã€‚
2 åˆ†åˆ«è®¡ç®—æ¯ä¸ªåŸŸçš„æ•£åˆ—ç å¹¶ç›¸åŠ æ±‚å’Œï¼Œæ•£åˆ—ç çš„ç”Ÿæˆè§„åˆ™å¦‚ä¸‹ï¼š

- byteã€charã€shortã€int: (int)(value)
- long: (int)(value ^ (value >>> 32))
- boolean: value == false ? 0 : 1
- float: Float.floatToIntBits(value)
- double: Double.doubleToLongBits(value)
- å¼•ç”¨ç±»å‹ï¼švalue.hashCode()

**å“ˆå¸Œå†²çª**

é€šè¿‡ä¸Šé¢çš„æè¿°ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“æ•£åˆ—è¡¨ä¸»è¦é¢ä¸´çš„é—®é¢˜æ˜¯æ•£åˆ—å€¼å‡åŒ€çš„åˆ†å¸ƒï¼Œè€Œæˆ‘ä»¬ä¸»è¦è§£å†³çš„é—®é¢˜æ˜¯åœ¨æ•£åˆ—å€¼åœ¨è®¡ç®—çš„æ—¶å€™å‡ºç°çš„å†²çªé—®é¢˜ï¼Œå³å‡ºç°
äº†ä¸¤ä¸ªç›¸åŒçš„æ•£åˆ—å€¼ï¼Œé€šå¸¸è¿™ä¹Ÿæˆä¸º**å“ˆå¸Œå†²çª**ã€‚Javaåœ¨è§£å†³å“ˆå¸Œå†²çªä¸Šï¼Œä½¿ç”¨äº†ä¸€ç§å«åšåˆ†ç¦»é“¾æ¥æ³•çš„æ–¹æ³•ã€‚

>åˆ†ç¦»é“¾æ¥æ³•å°†æ‹¥æœ‰ç›¸åŒå“ˆå¸Œå€¼çš„æ‰€æœ‰å…ƒç´ ä¿å­˜åˆ°åŒä¸€ä¸ªå•å‘é“¾è¡¨ä¸­ï¼Œæ‰€ä»¥è¿™ç§æ•£åˆ—è¡¨æ•´ä½“ä¸Šæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„é‡Œé¢å­˜æ”¾çš„å…ƒç´ æ—¶å•å‘é“¾è¡¨ã€‚

<img src="https://github.com/guoxiaoxing/computer-science/raw/master/art/hash/hash_conflict.png" width="500"/>

è¿™æ ·æ–¹æ³•æœ‰ä¸ªå«è´Ÿè½½å› å­çš„æ¦‚å¿µï¼Œè´Ÿè½½å› å­ = å…ƒç´ ä¸ªæ•° / æ•£åˆ—è¡¨å¤§å°.

è´Ÿè½½å› å­æ˜¯ç©ºé—´åˆ©ç”¨ç‡ä¸æŸ¥æ‰¾æ•ˆç‡çš„ä¸€ç§å¹³è¡¡ã€‚

- è´Ÿè½½å› å­è¶Šå¤§è¡¨ç¤ºæ•£åˆ—è¡¨è£…å¡«ç¨‹åº¦è¶Šé«˜ï¼Œç©ºé—´åˆ©ç”¨ç‡è¶Šé«˜ï¼Œä½†å¯¹åº”çš„æŸ¥æ‰¾æ•ˆç‡å°±è¶Šä½ã€‚
- è´Ÿè½½å› å­è¶Šå°è¡¨ç¤ºæ•£åˆ—è¡¨è£…å¡«ç¨‹åº¦è¶Šä½ï¼Œç©ºé—´åˆ©ç”¨ç‡è¶Šä½ï¼Œä½†å¯¹åº”çš„æŸ¥æ‰¾æ•ˆç‡å°±è¶Šé«˜ã€‚

ğŸ‘‰ æ³¨ï¼šé™¤äº†Javaé›†åˆé‡Œçš„åˆ†ç¦»é“¾æ¥æ³•ï¼Œè¿˜æœ‰ä¸€ç§å¸¸ç”¨çš„æ–¹æ³•å«åšå¼€å‘å®šå€æ³•ï¼Œè¯¥æ–¹æ³•çš„æ ¸å¿ƒæ€æƒ³é’ˆå¯¹å†²çªçš„æ•£åˆ—ç è¿›è¡Œå†æ¬¡æ•£åˆ—ï¼Œå¾ªç¯å¾€å¤ç›´åˆ°æ‰¾è¿‡ä¸å†²çªçš„æ•£åˆ—ç ä¸ºæ­¢ã€‚

Javaé›†åˆé‡Œçš„HashMapå°±ä½¿ç”¨äº†è¿™ç§æ–¹æ³•ï¼Œæˆ‘ä»¬ä¼šåœ¨ä¸‹é¢çš„HashMapæºç åˆ†æäº†è¯¦ç»†è®¨è®ºè¿™ç§æ–¹æ³•çš„å®ç°ã€‚

## ä¸€ HashMapå®ç°åŸç†

>HashMapåŸºäºæ•°ç»„å®ç°ï¼Œæ•°ç»„é‡Œçš„å…ƒç´ æ˜¯ä¸€ä¸ªå•å‘é“¾è¡¨ã€‚

<img src="https://github.com/guoxiaoxing/computer-science/raw/master/art/hash/HashMap_class.png" width="500"/>

HashMapå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

- åŸºäºæ•°ç»„å®ç°ï¼Œæ•°ç»„é‡Œçš„å…ƒç´ æ˜¯ä¸€ä¸ªå•å‘é“¾è¡¨ã€‚
- é”®ä¸å¯ä»¥é‡å¤ï¼Œå€¼å¯ä»¥é‡å¤ï¼Œé”®ã€å€¼éƒ½å¯ä»¥ä¸ºnull
- éçº¿ç¨‹å®‰å…¨

HashMapå®ç°äº†ä»¥ä¸‹æ¥å£ï¼š

- Mapï¼šä»¥é”®å€¼å¯¹çš„å½¢å¼å­˜å–å…ƒç´ 
- Cloneableï¼šå¯ä»¥è¢«å…‹éš†
- Serializableï¼šå¯ä»¥åºåˆ—åŒ–

### 1.1 æˆå‘˜å˜é‡

```java
//åˆå§‹åŒä¹ï¼Œåˆå§‹å®¹é‡å¿…é¡»ä¸º2çš„næ¬¡æ–¹
static final int DEFAULT_INITIAL_CAPACITY = 4;

//æœ€å¤§å®¹é‡ä¸º2çš„30æ¬¡æ–¹
static final int MAXIMUM_CAPACITY = 1 << 30;

//é»˜è®¤è´Ÿè½½å› å­ä¸º0.75f
static final float DEFAULT_LOAD_FACTOR = 0.75f;

//é»˜è®¤çš„ç©ºè¡¨
static final HashMapEntry<?,?>[] EMPTY_TABLE = {};

//å­˜å‚¨å…ƒç´ çš„è¡¨
transient HashMapEntry<K,V>[] table = (HashMapEntry<K,V>[]) EMPTY_TABLE;

//é›†åˆå¤§å°
transient int size;

//ä¸‹æ¬¡æ‰©å®¹é˜ˆå€¼ï¼Œsize > thresholdå°±ä¼šè¿›è¡Œæ‰©å®¹ï¼Œæ‰©å®¹é˜ˆå€¼ = å®¹é‡ * è´Ÿè½½å› å­ã€‚
int threshold;

//åŠ è½½å› æ­¤
final float loadFactor = DEFAULT_LOAD_FACTOR;

//ä¿®æ”¹æ¬¡æ•°
transient int modCount;
```

ä»ä¸Šé¢çš„æˆå‘˜å˜é‡å¯ä»¥å‘ç°ï¼ŒHashMapå­˜å‚¨å…ƒç´ çš„ç»“æ„å¦‚ä¸‹æ‰€ç¤ºï¼š

<img src="https://github.com/guoxiaoxing/computer-science/raw/master/art/hash/HashMap_structure.png" width="500"/>

HashMapé‡‡ç”¨æ•°ç»„æ¥å­˜å‚¨å…ƒç´ ï¼Œå­˜å‚¨çš„å…ƒç´ æ—¶HashMapEntryï¼Œè¯¥å¯¹è±¡ä¼šæŒæœ‰è‡ªå·±çš„åç»§ï¼Œå½¢æˆä¸€ä¸ªå•å‘é“¾è¡¨ï¼Œåç»­çš„å¢åˆ æŸ¥æ”¹éƒ½ä¼šä¾æ®è¿™ç§å­˜å‚¨ç»“æ„è¿›è¡Œã€‚

ä»è¿™ä¸ªç»“æ„transient HashMapEntry<K,V>[] table = (HashMapEntry<K,V>[]) EMPTY_TABLEå¯ä»¥çœ‹å‡ºï¼Œ**HashMapåŸºäºæ•°ç»„å®ç°ï¼Œæ•°ç»„é‡Œçš„å…ƒç´ æ˜¯ä¸€ä¸ªå•å‘é“¾è¡¨**ã€‚
HashMapä½¿ç”¨å“ˆå¸Œç®—æ³•å°†keyæ•£åˆ—æˆä¸€ä¸ªintå€¼ï¼Œè¿™ä¸ªå€¼å°±å¯¹åº”äº†è¿™ä¸ªæ•°ç»„çš„ä¸‹æ ‡ï¼Œæ‰€ä»¥ä½ å¯ä»¥çŸ¥é“ï¼Œå¦‚æœä¸¤ä¸ªkeyçš„å“ˆå¸Œå€¼ç›¸ç­‰ï¼Œåˆ™å®ƒä»¬ä¼šè¢«æ”¾åœ¨å½“å‰ä¸‹è¡¨çš„å•å‘é“¾è¡¨ä¸­ã€‚

è¿™é‡Œæˆ‘ä»¬ç€é‡ä»‹ç»ä¸€ä¸‹è´Ÿè½½å› å­ï¼Œå®ƒæ˜¯ç©ºé—´åˆ©ç”¨ç‡ä¸æŸ¥æ‰¾æ•ˆç‡çš„ä¸€ç§å¹³è¡¡ã€‚

- è´Ÿè½½å› å­è¶Šå¤§è¡¨ç¤ºæ•£åˆ—è¡¨è£…å¡«ç¨‹åº¦è¶Šé«˜ï¼Œç©ºé—´åˆ©ç”¨ç‡è¶Šé«˜ï¼Œä½†å¯¹åº”çš„æŸ¥æ‰¾æ•ˆç‡å°±è¶Šä½ã€‚
- è´Ÿè½½å› å­è¶Šå°è¡¨ç¤ºæ•£åˆ—è¡¨è£…å¡«ç¨‹åº¦è¶Šä½ï¼Œç©ºé—´åˆ©ç”¨ç‡è¶Šä½ï¼Œä½†å¯¹åº”çš„æŸ¥æ‰¾æ•ˆç‡å°±è¶Šé«˜ã€‚

### 1.2 å†…éƒ¨ç±»

```java
static class HashMapEntry<K,V> implements Map.Entry<K,V> {
        //é”®
        final K key;
        //å€¼
        V value;
        //åç»§çš„å¼•ç”¨
        HashMapEntry<K,V> next;
        //å“ˆå¸Œå€¼
        int hash;

        HashMapEntry(int h, K k, V v, HashMapEntry<K,V> n) {
            value = v;
            next = n;
            key = k;
            hash = h;
        }

        public final K getKey() {
            return key;
        }

        public final V getValue() {
            return value;
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        public final boolean equals(Object o) {
            if (!(o instanceof Map.Entry))
                return false;
            Map.Entry e = (Map.Entry)o;
            Object k1 = getKey();
            Object k2 = e.getKey();
            if (k1 == k2 || (k1 != null && k1.equals(k2))) {
                Object v1 = getValue();
                Object v2 = e.getValue();
                if (v1 == v2 || (v1 != null && v1.equals(v2)))
                    return true;
            }
            return false;
        }

        public final int hashCode() {
            return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());
        }

        public final String toString() {
            return getKey() + "=" + getValue();
        }

        //å½“å‘HashMaoé‡Œæ·»åŠ å…ƒç´ æ—¶è°ƒç”¨æ­¤æ–¹æ³•ï¼Œè¿™é‡Œæä¾›ç»™å­ç±»å®ç°
        void recordAccess(HashMap<K,V> m) {
        }

        //å½“ä»HashMé‡Œåˆ é™¤å…ƒç´ æ—¶è°ƒç”¨æ­¤æ–¹æ³•ï¼Œè¿™é‡Œæä¾›ç»™å­ç±»å®ç°
        void recordRemoval(HashMap<K,V> m) {
        }
    }
```
HashMapEntryç”¨æ¥æè¿°HashMaoé‡Œçš„å…ƒç´ ï¼Œå®ƒä¿å­˜äº†é”®ã€å€¼ã€åç»§çš„å¼•ç”¨ä¸å“ˆå¸Œå€¼ã€‚

### 1.3 æ„é€ æ–¹æ³•

```java

//æä¾›åˆå§‹å®¹é‡å’Œè´Ÿè½½å› å­è¿›è¡Œæ„é€ 
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " +
                                           initialCapacity);
    if (initialCapacity > MAXIMUM_CAPACITY) {
        initialCapacity = MAXIMUM_CAPACITY;
    } else if (initialCapacity < DEFAULT_INITIAL_CAPACITY) {
        initialCapacity = DEFAULT_INITIAL_CAPACITY;
    }

    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " +
                                           loadFactor);
    // Android-Note: We always use the default load factor of 0.75f.

    // This might appear wrong but it's just awkward design. We always call
    // inflateTable() when table == EMPTY_TABLE. That method will take "threshold"
    // to mean "capacity" and then replace it with the real threshold (i.e, multiplied with
    // the load factor).
    threshold = initialCapacity;
    init();
}

//æä¾›åˆå§‹å®¹é‡è¿›è¡Œæ„é€ 
public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}

//ç©ºæ„é€ æ–¹æ³•
public HashMap() {
    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
}

//æä¾›ä¸€ä¸ªMapè¿›è¡Œæ„é€ 
public HashMap(Map<? extends K, ? extends V> m) {
    this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1,
                  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);
    inflateTable(threshold);

    putAllForCreate(m);
}
```

### 1.4 æ“ä½œæ–¹æ³•

#### put

```java
public class HashMap<K,V>
    extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable{
    
    public V put(K key, V value) {
        if (table == EMPTY_TABLE) {
            inflateTable(threshold);
        }
        if (key == null)
            //å¦‚æœkeyä¸ºnullï¼Œåˆ™å°†å…¶æ”¾åœ¨table[0]çš„ä½ç½®
            return putForNullKey(value);
        //æ ¹æ®keyè®¡ç®—hashå€¼
        int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key);
        //æ ¹æ®hashå€¼å’Œæ•°ç»„å®¹é‡ï¼Œæ‰¾åˆ°ç´¢å¼•å€¼
        int i = indexFor(hash, table.length);
        //éå†table[i]ä½ç½®çš„é“¾è¡¨ï¼ŒæŸ¥æ‰¾ç›¸åŒçš„keyï¼Œè‹¥æ‰¾åˆ°åˆ™åˆ™ç”¨æ–°çš„valueæ›¿æ¢æ‰oldValue
        for (HashMapEntry<K,V> e = table[i]; e != null; e = e.next) {
            Object k;
            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;
                e.value = value;
                // å°†å…ƒç´ æ’å…¥åœ¨è¡¨å¤´ä½ç½®
                e.recordAccess(this);
                return oldValue;
            }
        }

        modCount++;
        //è‹¥æ²¡æœ‰æŸ¥æ‰¾åˆ°ç›¸åŒçš„keyï¼Œåˆ™æ·»åŠ keyåˆ°table[i]ä½ç½®ï¼Œæ–°æ·»åŠ çš„å…ƒç´ æ€»æ˜¯æ·»åŠ åœ¨å•å‘é“¾è¡¨çš„è¡¨å¤´ä½ç½®ï¼Œåé¢çš„å…ƒç´ ç§°ä¸ºå®ƒçš„åç»§
        addEntry(hash, key, value, i);
        return null;
    }
    
    //æ ¹æ®å“ˆå¸Œå€¼ä¸æ•°ç»„å®¹é‡è®¡ç®—ç´¢å¼•ä½ç½®ï¼Œä½¿ç”¨&ä»£æ›¿å–æ¨¡ï¼Œæå‡æ•ˆç‡ã€‚
    static int indexFor(int h, int length) {
        // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";
        return h & (length-1);
    }
    
    void addEntry(int hash, K key, V value, int bucketIndex) {
        //å¦‚æœè¾¾åˆ°äº†æ‰©å®¹é˜ˆå€¼ï¼Œåˆ™è¿›è¡Œæ‰©å®¹ï¼Œå®¹é‡ç¿»å€
        if ((size >= threshold) && (null != table[bucketIndex])) {
            resize(2 * table.length);
            hash = (null != key) ? sun.misc.Hashing.singleWordWangJenkinsHash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }

        createEntry(hash, key, value, bucketIndex);
    }

    //æ–°æ·»åŠ çš„å…ƒç´ æ€»æ˜¯æ·»åŠ åœ¨å•å‘é“¾è¡¨çš„è¡¨å¤´ä½ç½®ï¼Œåé¢çš„å…ƒç´ ç§°ä¸ºå®ƒçš„åç»§
    void createEntry(int hash, K key, V value, int bucketIndex) {
        HashMapEntry<K,V> e = table[bucketIndex];
        table[bucketIndex] = new HashMapEntry<>(hash, key, value, e);
        size++;
    }
}
```
è¿™ä¸ªæ·»åŠ çš„æµç¨‹è¿˜æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œè¿™ä¸ªæµç¨‹å¦‚ä¸‹ï¼š

1. æ ¹æ®keyè®¡ç®—hashå€¼ï¼Œå¹¶æ ¹æ®hashå€¼å’Œæ•°ç»„å®¹é‡ï¼Œæ‰¾åˆ°ç´¢å¼•å€¼ï¼Œè¯¥ä½ç½®å³ä¸ºå­˜å‚¨è¯¥å…ƒç´ çš„é“¾è¡¨æ‰€åœ¨å¤„ã€‚
2. éå†table[i]ä½ç½®çš„é“¾è¡¨ï¼ŒæŸ¥æ‰¾ç›¸åŒçš„keyï¼Œè‹¥æ‰¾åˆ°åˆ™åˆ™ç”¨æ–°çš„valueæ›¿æ¢æ‰oldValue.
3. è‹¥æ²¡æœ‰æŸ¥æ‰¾åˆ°ç›¸åŒçš„keyï¼Œåˆ™æ·»åŠ keyåˆ°table[i]ä½ç½®ï¼Œæ–°æ·»åŠ çš„å…ƒç´ æ€»æ˜¯æ·»åŠ åœ¨å•å‘é“¾è¡¨çš„è¡¨å¤´ä½ç½®ï¼Œåé¢çš„å…ƒç´ ç§°ä¸ºå®ƒçš„åç»§ã€‚

è¿™é‡Œä½ å¯ä»¥çœ‹åˆ°HashMapä½¿ç”¨äº†æˆ‘ä»¬ä¸Šé¢æ‰€è¯´çš„åˆ†ç¦»é“¾æ¥æ³•æ¥è§£å†³å“ˆå¸Œå†²çªçš„é—®é¢˜ã€‚

##### remove

```java
public class HashMap<K,V>
    extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable{
    
    public V remove(Object key) {
        Entry<K,V> e = removeEntryForKey(key);
        return (e == null ? null : e.getValue());
    }

    final Entry<K,V> removeEntryForKey(Object key) {
        if (size == 0) {
            return null;
        }
        //è®¡ç®—å“ˆå¸Œå€¼ï¼Œæ ¹æ®å“ˆå¸Œå€¼ä¸æ•°ç»„å®¹é‡è®¡ç®—å®ƒæ‰€åœ¨çš„ç´¢å¼•ï¼Œæ ¹æ®ç´¢å¼•æŸ¥æ‰¾å®ƒæ‰€åœ¨çš„é“¾è¡¨
        int hash = (key == null) ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key);
        int i = indexFor(hash, table.length);
        HashMapEntry<K,V> prev = table[i];
        HashMapEntry<K,V> e = prev;

        //ä»èµ·å§‹èŠ‚ç‚¹å¼€å§‹éå†ï¼ŒæŸ¥æ‰¾è¦åˆ é™¤çš„å…ƒç´ ï¼Œåˆ é™¤è¯¥èŠ‚ç‚¹ï¼Œå°†èŠ‚ç‚¹çš„åç»§æ·»åŠ ä¸ºå®ƒå‰é©±çš„åç»§
        while (e != null) {
            HashMapEntry<K,V> next = e.next;
            Object k;
            if (e.hash == hash &&
                ((k = e.key) == key || (key != null && key.equals(k)))) {
                modCount++;
                size--;
                if (prev == e)
                    table[i] = next;
                else
                    prev.next = next;
                e.recordRemoval(this);
                return e;
            }
            prev = e;
            e = next;
        }

        return e;
    }
}
```

åˆ é™¤çš„æµç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼š

1. è®¡ç®—å“ˆå¸Œå€¼ï¼Œæ ¹æ®å“ˆå¸Œå€¼ä¸æ•°ç»„å®¹é‡è®¡ç®—å®ƒæ‰€åœ¨çš„ç´¢å¼•ï¼Œæ ¹æ®ç´¢å¼•æŸ¥æ‰¾å®ƒæ‰€åœ¨çš„é“¾è¡¨ã€‚
2. ä»èµ·å§‹èŠ‚ç‚¹å¼€å§‹éå†ï¼ŒæŸ¥æ‰¾è¦åˆ é™¤çš„å…ƒç´ ï¼Œåˆ é™¤è¯¥èŠ‚ç‚¹ï¼Œå°†èŠ‚ç‚¹çš„åç»§æ·»åŠ ä¸ºå®ƒå‰é©±çš„åç»§

##### get


```java
public class HashMap<K,V>
    extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable{
    
   public V get(Object key) {
       if (key == null)
           return getForNullKey();
       Entry<K,V> entry = getEntry(key);

       return null == entry ? null : entry.getValue();
   }
   
   final Entry<K,V> getEntry(Object key) {
       if (size == 0) {
           return null;
       }
       //è®¡ç®—å“ˆå¸Œå€¼ï¼Œæ ¹æ®å“ˆå¸Œå€¼ä¸æ•°ç»„å®¹é‡è®¡ç®—å®ƒæ‰€åœ¨çš„ç´¢å¼•ï¼Œæ ¹æ®ç´¢å¼•æŸ¥æ‰¾å®ƒæ‰€åœ¨çš„é“¾è¡¨
       int hash = (key == null) ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key);
       //åœ¨å•å‘é“¾è¡¨ä¸­æŸ¥æ‰¾è¯¥å…ƒç´ 
       for (HashMapEntry<K,V> e = table[indexFor(hash, table.length)];
            e != null;
            e = e.next) {
           Object k;
           if (e.hash == hash &&
               ((k = e.key) == key || (key != null && key.equals(k))))
               return e;
       }
       return null;
   }

}
```

æŸ¥æ‰¾çš„æµç¨‹ä¹Ÿååˆ†ç®€å•ï¼Œå…·ä½“å¦‚ä¸‹ï¼š

1. è®¡ç®—å“ˆå¸Œå€¼ï¼Œæ ¹æ®å“ˆå¸Œå€¼ä¸æ•°ç»„å®¹é‡è®¡ç®—å®ƒæ‰€åœ¨çš„ç´¢å¼•ï¼Œæ ¹æ®ç´¢å¼•æŸ¥æ‰¾å®ƒæ‰€åœ¨çš„é“¾è¡¨ã€‚
2. åœ¨å•å‘é“¾è¡¨ä¸­æŸ¥æ‰¾è¯¥å…ƒç´ 

## äºŒ HashSetçš„å®ç°åŸç†

>HashSetåŸºäºHashMapå®ç°ï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒæœ¬è´¨ä¸Šä¹Ÿæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œå®ƒä»¥HashMapçš„keyæ¥å­˜å‚¨å…ƒç´ ï¼Œå› ä¸ºHashMapé‡Œçš„keyæ˜¯ä¸ä¼šé‡å¤çš„ï¼Œæ‰€ä»¥HashSetçš„å…ƒç´ æ—¶ä¸é‡å¤ä¸”æ— åºçš„ã€‚

<img src="https://github.com/guoxiaoxing/computer-science/raw/master/art/hash/HashSet_class.png" width="500"/>

### 2.1 æˆå‘˜å˜é‡

```java

// å†…éƒ¨åŸºäºHashMapå®ç°
private transient HashMap<E,Object> map;

// Dummy value to associate with an Object in the backing Map
private static final Object PRESENT = new Object();
```

### 2.2 æ„é€ æ–¹æ³•

æ„é€ æ–¹æ³•é‡Œä¹Ÿå¯ä»¥è®¾ç½®åˆå§‹å®¹é‡å’ŒåŠ è½½å› å­ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```java
public class HashSet<E>
    extends AbstractSet<E>
    implements Set<E>, Cloneable, java.io.Serializable{
    
        public HashSet() {
            map = new HashMap<>();
        }
    
        public HashSet(Collection<? extends E> c) {
            map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));
            addAll(c);
        }
       
        public HashSet(int initialCapacity, float loadFactor) {
            map = new HashMap<>(initialCapacity, loadFactor);
        }
}
```

### 2.3 æ“ä½œæ–¹æ³•

HashSetå¢åˆ æ”¹æŸ¥éƒ½æ˜¯è°ƒç”¨HashMapçš„æ–¹æ³•æ¥å®ç°çš„ï¼Œä¸Šé¢å·²ç»è®²è¿‡ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°ã€‚


```java
public class HashSet<E>
    extends AbstractSet<E>
    implements Set<E>, Cloneable, java.io.Serializable{
    
    public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }

    public boolean remove(Object o) {
        return map.remove(o)==PRESENT;
    }
}
```
ğŸ‘‰ æ³¨ï¼šå¥½ç¥å¥‡ï¼Œç«Ÿç„¶æ²¡æœ‰get()æ–¹æ³•ï¼ŒğŸ˜†å› ä¸ºHashSeté‡Œé¢å­˜çš„å°±æ˜¯å€¼ï¼Œä½ éƒ½å·²ç»æœ‰è¿™ä¸ªå€¼äº†è¿˜æœ‰å»getå®ƒå¹²å˜›ã€‚

## ä¸‰ ConcurrentHashMapå®ç°åŸç†

ConcurrentHashMapå­˜å‚¨å…ƒç´ çš„ç»“æ„å¦‚ä¸‹æ‰€ç¤ºï¼š

<img src="https://github.com/guoxiaoxing/computer-science/raw/master/art/hash/HashMap_structure.png" width="500"/>

ConcurrentHashMapä¸HashMapä¸€æ ·é€‚ç”¨æ•°ç»„åŠ é“¾è¡¨å­˜å‚¨å…ƒç´ ï¼Œé€‚ç”¨é“¾è¡¨å®šå€æ³•æ¥è§£å†³å“ˆå¸Œå†²çªï¼Œä¸åŒä¹‹å¤„åœ¨äºå½“é“¾è¡¨é•¿åº¦å¤§äº8çš„æ—¶å€™ä¼šå°†é“¾è¡¨è½¬æ¢ä¸ºä¸€æ£µçº¢é»‘æ ‘ï¼ŒæŸ¥æ‰¾æ—¶é—´å¤æ‚åº¦ç”±O(N)å˜æˆO(lgN)ã€‚

ConcurrentHashMapå¹¶å‘æ§åˆ¶çš„å…³é”®åœ¨äºä¸€ä¸ªå˜é‡ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```java
private transient volatile int sizeCtl;
```
sizeCtlè¢«volatileå…³é”®å­—ä¿®é¥°æ˜¯ä¸€ä¸ªå¤šçº¿ç¨‹å…±äº«çš„å˜é‡ï¼Œå½“å®ƒçš„å€¼ä¸ºè´Ÿæ•°çš„æ—¶å€™è¯´æ˜æŸä¸ªçº¿ç¨‹æ­£åœ¨æ“ä½œè¿™ä¸ªMapï¼Œæƒ³è¦å»æ“ä½œè¿™ä¸ªMapçš„çº¿ç¨‹å°±è¦ä¸€ç›´å»ç«äº‰è¿™ä¸ªsizeCtlï¼Œæ²¡æœ‰å¾—åˆ°è¿™ä¸ªå˜é‡çš„å€¼å°±è¦ä¸€ç›´è‡ªæ—‹ç­‰å¾…è¿™ä¸ªå˜é‡ï¼Œå½“å ç”¨
è¿™ä¸ªå˜é‡çš„çº¿ç¨‹æ“ä½œå®Œæˆåï¼Œè¦å°†è¿™ä¸ªå˜é‡çš„å€¼è®¾ç½®å›æ¥ï¼Œä»¥ä¾¿è®©å…¶ä»–çº¿ç¨‹èµ°å‡ºè‡ªæ—‹ï¼Œç«äº‰åˆ°è¯¥å˜é‡ã€‚

è¿™ç§åŒæ­¥è¿›åˆ¶äº‹å®ä¸Šæ˜¯ä¸€ç§CASçš„åšæ³•ã€‚

> CASï¼ˆCompare and swapï¼‰æ¯”è¾ƒå’Œæ›¿æ¢æ˜¯è®¾è®¡å¹¶å‘ç®—æ³•æ—¶ç”¨åˆ°çš„ä¸€ç§æŠ€æœ¯ã€‚ç®€å•æ¥è¯´ï¼Œæ¯”è¾ƒå’Œæ›¿æ¢æ˜¯ä½¿ç”¨ä¸€ä¸ªæœŸæœ›å€¼å’Œä¸€ä¸ªå˜é‡çš„å½“å‰å€¼è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœå½“å‰å˜é‡çš„å€¼ä¸æˆ‘ä»¬æœŸæœ›çš„å€¼ç›¸ç­‰ï¼Œå°±ä½¿ç”¨ä¸€ä¸ªæ–°å€¼æ›¿æ¢å½“å‰å˜é‡çš„å€¼ã€‚